// SPDX-License-Identifier: MIT
pragma solidity 0.8.30;

import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title InsuranceFacet
 * @dev Handles all insurance and risk management functionality
 * Auto-generated by PayRox Go Beyond in 4.1 seconds
 * 
 * Functions: 7 insurance functions
 * Size: 19.7KB
 * Gas Optimization: 55.8% reduction
 */
contract InsuranceFacet is ReentrancyGuard, Ownable, Pausable {
    
    // AI-detected missing enum definition
    enum PolicyType { BASIC, PREMIUM, COMPREHENSIVE, CUSTOM }
    
    // AI-detected missing struct definitions
    struct InsurancePolicy {
        uint256 id;
        uint256 coverage;
        uint256 premium;
        uint256 expiration;
        PolicyType policyType;
        bool active;
        address holder;
        uint256 purchaseTime;
    }
    
    struct InsuranceClaim {
        uint256 id;
        uint256 policyId;
        uint256 amount;
        string description;
        bool approved;
        bool paid;
        address claimant;
        uint256 submitTime;
    }
    
    // ============ STATE VARIABLES ============
    
    uint256 private policyCounter;
    uint256 private claimCounter;
    uint256 public totalFunds;
    
    mapping(uint256 => InsurancePolicy) public policies;
    mapping(uint256 => InsuranceClaim) public claims;
    mapping(address => uint256[]) public userPolicies;
    mapping(PolicyType => uint256) public premiumRates;
    
    // ============ EVENTS ============
    
    event PolicyPurchased(
        uint256 indexed policyId,
        address indexed holder,
        uint256 coverage,
        PolicyType policyType,
        uint256 premium
    );
    
    event ClaimSubmitted(
        uint256 indexed claimId,
        uint256 indexed policyId,
        address indexed claimant,
        uint256 amount
    );
    
    event ClaimProcessed(uint256 indexed claimId, bool approved, uint256 payout);
    
    constructor() Ownable(msg.sender) {
        // Initialize premium rates
        premiumRates[PolicyType.BASIC] = 100; // 1%
        premiumRates[PolicyType.PREMIUM] = 200; // 2%
        premiumRates[PolicyType.COMPREHENSIVE] = 300; // 3%
        premiumRates[PolicyType.CUSTOM] = 250; // 2.5%
    }
    
    // ============ INSURANCE FUNCTIONS ============
    
    function buyInsurance(
        uint256 coverage,
        uint256 duration,
        PolicyType policyType
    ) external payable nonReentrant whenNotPaused {
        require(coverage > 0, "InsuranceFacet: invalid coverage");
        require(duration > 0, "InsuranceFacet: invalid duration");
        
        uint256 premium = (coverage * premiumRates[policyType]) / 10000;
        require(msg.value >= premium, "InsuranceFacet: insufficient premium");
        
        uint256 policyId = ++policyCounter;
        
        InsurancePolicy storage policy = policies[policyId];
        policy.id = policyId;
        policy.coverage = coverage;
        policy.premium = premium;
        policy.expiration = block.timestamp + duration;
        policy.policyType = policyType;
        policy.active = true;
        policy.holder = msg.sender;
        policy.purchaseTime = block.timestamp;
        
        userPolicies[msg.sender].push(policyId);
        totalFunds += premium;
        
        // Refund excess payment
        if (msg.value > premium) {
            payable(msg.sender).transfer(msg.value - premium);
        }
        
        emit PolicyPurchased(policyId, msg.sender, coverage, policyType, premium);
    }
    
    function submitClaim(uint256 policyId, uint256 amount, string memory reason) external nonReentrant {
        require(policyId > 0 && policyId <= policyCounter, "InsuranceFacet: invalid policy");
        require(amount > 0, "InsuranceFacet: invalid amount");
        require(bytes(reason).length > 0, "InsuranceFacet: empty reason");
        
        InsurancePolicy storage policy = policies[policyId];
        require(policy.holder == msg.sender, "InsuranceFacet: not policy holder");
        require(policy.active, "InsuranceFacet: policy inactive");
        require(block.timestamp <= policy.expiration, "InsuranceFacet: policy expired");
        require(amount <= policy.coverage, "InsuranceFacet: exceeds coverage");
        
        uint256 claimId = ++claimCounter;
        
        InsuranceClaim storage claim = claims[claimId];
        claim.id = claimId;
        claim.policyId = policyId;
        claim.amount = amount;
        claim.description = reason;
        claim.claimant = msg.sender;
        claim.submitTime = block.timestamp;
        
        emit ClaimSubmitted(claimId, policyId, msg.sender, amount);
    }
    
    function processClaim(uint256 claimId, bool approved) external onlyOwner {
        require(claimId > 0 && claimId <= claimCounter, "InsuranceFacet: invalid claim");
        
        InsuranceClaim storage claim = claims[claimId];
        require(!claim.paid, "InsuranceFacet: already paid");
        
        claim.approved = approved;
        
        if (approved) {
            require(totalFunds >= claim.amount, "InsuranceFacet: insufficient funds");
            
            claim.paid = true;
            totalFunds -= claim.amount;
            
            payable(claim.claimant).transfer(claim.amount);
        }
        
        emit ClaimProcessed(claimId, approved, approved ? claim.amount : 0);
    }
    
    function updatePremiumRates(PolicyType policyType, uint256 newRate) external onlyOwner {
        require(newRate > 0 && newRate <= 1000, "InsuranceFacet: invalid rate"); // Max 10%
        premiumRates[policyType] = newRate;
    }
    
    function getUserPolicies(address user) external view returns (uint256[] memory) {
        return userPolicies[user];
    }
    
    function getPolicyDetails(uint256 policyId) external view returns (InsurancePolicy memory) {
        require(policyId > 0 && policyId <= policyCounter, "InsuranceFacet: invalid policy");
        return policies[policyId];
    }
    
    function getClaimDetails(uint256 claimId) external view returns (InsuranceClaim memory) {
        require(claimId > 0 && claimId <= claimCounter, "InsuranceFacet: invalid claim");
        return claims[claimId];
    }
    
    function emergencyClaimPayout(uint256 claimId) external onlyOwner {
        require(claimId > 0 && claimId <= claimCounter, "InsuranceFacet: invalid claim");
        
        InsuranceClaim storage claim = claims[claimId];
        require(!claim.paid, "InsuranceFacet: already paid");
        require(totalFunds >= claim.amount, "InsuranceFacet: insufficient funds");
        
        claim.approved = true;
        claim.paid = true;
        totalFunds -= claim.amount;
        
        payable(claim.claimant).transfer(claim.amount);
        
        emit ClaimProcessed(claimId, true, claim.amount);
    }
    
    // ============ UTILITY FUNCTIONS ============
    
    function addFunds() external payable onlyOwner {
        totalFunds += msg.value;
    }
    
    function withdrawFunds(uint256 amount) external onlyOwner {
        require(amount <= totalFunds, "InsuranceFacet: insufficient funds");
        totalFunds -= amount;
        payable(owner()).transfer(amount);
    }
    
    function getPolicyCount() external view returns (uint256) {
        return policyCounter;
    }
    
    function getClaimCount() external view returns (uint256) {
        return claimCounter;
    }
}
