/**
 * PayRox SDK Development Tools
 * Enhanced developer experience utilities
 */

import { ethers } from 'ethers';
import { PayRoxClient } from './client';
import { NETWORKS } from './config';

export class DevTools {
  private readonly client: PayRoxClient;

  constructor(client: PayRoxClient) {
    this.client = client;
  }

  /**
   * Network health check
   */
  async checkNetworkHealth(): Promise<{
    network: string;
    chainId: number;
    blockNumber: number;
    gasPrice: string;
    payRoxAvailable: boolean;
    contractsHealthy: boolean;
  }> {
    const network = this.client.getNetwork();
    const provider = this.client['provider'];

    try {
      const [blockNumber, feeData] = await Promise.all([
        provider.getBlockNumber(),
        provider.getFeeData(),
      ]);

      // Check PayRox contract availability
      const factoryCode = await provider.getCode(network.contracts.factory);
      const dispatcherCode = await provider.getCode(
        network.contracts.dispatcher
      );

      const payRoxAvailable = factoryCode !== '0x' && dispatcherCode !== '0x';
      const contractsHealthy =
        factoryCode.length > 10 && dispatcherCode.length > 10;

      return {
        network: network.name,
        chainId: network.chainId,
        blockNumber,
        gasPrice: ethers.formatUnits(feeData.gasPrice || 0, 'gwei'),
        payRoxAvailable,
        contractsHealthy,
      };
    } catch (error) {
      console.warn('Network health check failed:', error);
      return {
        network: network.name,
        chainId: network.chainId,
        blockNumber: 0,
        gasPrice: '0',
        payRoxAvailable: false,
        contractsHealthy: false,
      };
    }
  }

  /**
   * Generate deployment report
   */
  async generateDeploymentReport(bytecode: string): Promise<string> {
    const health = await this.checkNetworkHealth();
    const analysis = this.analyzeContract(bytecode);

    const report = `
# PayRox Deployment Report

## Network Information
- **Network**: ${health.network}
- **Chain ID**: ${health.chainId}
- **Block Number**: ${health.blockNumber}
- **Gas Price**: ${health.gasPrice} gwei
- **PayRox Available**: ${health.payRoxAvailable ? '‚úÖ' : '‚ùå'}

## Contract Analysis
- **Bytecode Size**: ${analysis.size.toLocaleString()} bytes
- **Size Category**: ${analysis.sizeCategory}
- **Estimated Complexity**: ${analysis.estimatedComplexity}
- **Has Constructor**: ${analysis.hasConstructor ? '‚úÖ' : '‚ùå'}

## Recommendations
${analysis.recommendations.map(rec => `- ${rec}`).join('\n')}

## Contract Information
- **Factory**: \`${this.client.getNetwork().contracts.factory}\`
- **Dispatcher**: \`${this.client.getNetwork().contracts.dispatcher}\`

---
_Generated by PayRox SDK DevTools_
`;

    return report.trim();
  }

  /**
   * Interactive deployment wizard
   */
  async deploymentWizard(options: {
    bytecode: string;
    dryRun?: boolean;
  }): Promise<{
    steps: string[];
    ready: boolean;
    warnings: string[];
    analysis: any;
  }> {
    const { bytecode, dryRun = false } = options;

    const steps: string[] = [];
    const warnings: string[] = [];

    steps.push('üîç Analyzing bytecode...');

    // Validate bytecode
    if (!bytecode.startsWith('0x')) {
      warnings.push('Bytecode should start with 0x');
    }

    if (bytecode.length < 10) {
      warnings.push('Bytecode appears too short');
    }

    const analysis = this.analyzeContract(bytecode);

    steps.push('üåê Checking network health...');
    const health = await this.checkNetworkHealth();

    if (!health.payRoxAvailable) {
      warnings.push('PayRox contracts not available on this network');
    }

    steps.push('‚ö° Validating contract requirements...');
    if (analysis.sizeCategory === 'oversized') {
      warnings.push('Contract size exceeds recommended limits');
    }

    const ready = warnings.length === 0 && health.payRoxAvailable;

    if (ready && !dryRun) {
      steps.push('üöÄ Ready for deployment!');
    } else if (dryRun) {
      steps.push('‚úÖ Dry run complete - no deployment executed');
    } else {
      steps.push('‚ö†Ô∏è  Issues detected - review warnings');
    }

    return {
      steps,
      ready,
      warnings,
      analysis,
    };
  }

  /**
   * Smart contract analyzer
   */
  analyzeContract(bytecode: string): {
    size: number;
    sizeCategory: 'small' | 'medium' | 'large' | 'oversized';
    hasConstructor: boolean;
    estimatedComplexity: 'low' | 'medium' | 'high';
    recommendations: string[];
  } {
    const size = Math.floor(bytecode.length / 2);
    const recommendations: string[] = [];

    let sizeCategory: 'small' | 'medium' | 'large' | 'oversized';
    if (size < 10000) sizeCategory = 'small';
    else if (size < 24000) sizeCategory = 'medium';
    else if (size < 48000) sizeCategory = 'large';
    else sizeCategory = 'oversized';

    if (sizeCategory === 'oversized') {
      recommendations.push('Consider splitting into multiple contracts');
    }

    const hasConstructor = bytecode.includes('6080604052'); // Common constructor pattern

    let estimatedComplexity: 'low' | 'medium' | 'high';
    if (size < 5000) estimatedComplexity = 'low';
    else if (size < 20000) estimatedComplexity = 'medium';
    else estimatedComplexity = 'high';

    if (estimatedComplexity === 'high') {
      recommendations.push(
        'High complexity detected - ensure thorough testing'
      );
    }

    if (recommendations.length === 0) {
      recommendations.push('Contract looks good for deployment');
    }

    return {
      size,
      sizeCategory,
      hasConstructor,
      estimatedComplexity,
      recommendations,
    };
  }
}

/**
 * Create development tools instance
 */
export function createDevTools(client: PayRoxClient): DevTools {
  return new DevTools(client);
}

/**
 * Quick network status check
 */
export async function quickNetworkCheck(
  networkName: string = 'localhost'
): Promise<{
  status: 'healthy' | 'degraded' | 'offline';
  message: string;
}> {
  try {
    const network = NETWORKS[networkName];
    if (!network) {
      return { status: 'offline', message: `Unknown network: ${networkName}` };
    }

    if (!network.rpcUrl) {
      return { status: 'offline', message: 'No RPC URL configured' };
    }

    const provider = new ethers.JsonRpcProvider(network.rpcUrl);
    const blockNumber = await provider.getBlockNumber();

    if (blockNumber > 0) {
      return {
        status: 'healthy',
        message: `Connected to ${network.name} (block ${blockNumber})`,
      };
    } else {
      return {
        status: 'degraded',
        message: 'Network responding but no blocks',
      };
    }
  } catch (error) {
    return {
      status: 'offline',
      message: `Network unreachable: ${String(error)}`,
    };
  }
}
