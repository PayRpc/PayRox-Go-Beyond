/**
 * OpenZeppelin Dynamic Configuration Manager
 * Handles runtime dependency resolution and version compatibility
 */

const fs = require('fs');
const path = require('path');

class OpenZeppelinDynamicManager {
    constructor() {
        this.packageJsonPath = path.join(process.cwd(), 'package.json');
        this.hardhatConfigPath = path.join(process.cwd(), 'hardhat.config.ts');
        this.supportedVersions = ['5.4.0', '5.3.0', '5.2.0', '5.1.0', '5.0.0', '4.9.0'];
        this.currentConfig = null;
    }

    /**
     * Initialize dynamic OZ configuration
     */
    async initialize() {
        console.log('ðŸ”§ Initializing OpenZeppelin Dynamic Configuration...');
        
        try {
            this.currentConfig = await this.loadCurrentConfig();
            await this.validateConfiguration();
            await this.createDynamicImports();
            
            console.log('âœ… OpenZeppelin dynamic configuration ready!');
            return true;
        } catch (error) {
            console.error('âŒ Failed to initialize OZ dynamic config:', error.message);
            return false;
        }
    }

    /**
     * Load current package configuration
     */
    async loadCurrentConfig() {
        const packageJson = JSON.parse(fs.readFileSync(this.packageJsonPath, 'utf8'));
        
        const ozDeps = {};
        const allDeps = { ...packageJson.dependencies, ...packageJson.devDependencies };
        
        Object.keys(allDeps).forEach(dep => {
            if (dep.startsWith('@openzeppelin/')) {
                ozDeps[dep] = allDeps[dep];
            }
        });

        return {
            packageJson,
            ozDependencies: ozDeps,
            mainVersion: allDeps['@openzeppelin/contracts'] || null,
            upgradesVersion: allDeps['@openzeppelin/contracts-upgradeable'] || null
        };
    }

    /**
     * Validate current OZ configuration
     */
    async validateConfiguration() {
        console.log('ðŸ” Validating OpenZeppelin configuration...');
        
        const { ozDependencies, mainVersion } = this.currentConfig;
        
        if (!mainVersion) {
            throw new Error('No @openzeppelin/contracts dependency found');
        }

        // Check version compatibility
        const cleanVersion = mainVersion.replace(/[\^~]/, '');
        const isSupported = this.supportedVersions.some(v => cleanVersion.startsWith(v.split('.')[0]));
        
        if (!isSupported) {
            console.warn(`âš ï¸  OpenZeppelin version ${cleanVersion} may not be fully supported`);
        }

        // Check for version mismatches
        const versions = Object.values(ozDependencies).map(v => v.replace(/[\^~]/, ''));
        const uniqueVersions = [...new Set(versions.map(v => v.split('.')[0]))];
        
        if (uniqueVersions.length > 1) {
            console.warn('âš ï¸  Multiple OpenZeppelin major versions detected:', uniqueVersions);
        }

        console.log(`âœ… OpenZeppelin v${cleanVersion} configuration validated`);
    }

    /**
     * Create dynamic import resolver
     */
    async createDynamicImports() {
        const resolverContent = this.generateImportResolver();
        const resolverPath = path.join(process.cwd(), 'scripts', 'oz-dynamic-resolver.js');
        
        // Ensure scripts directory exists
        const scriptsDir = path.dirname(resolverPath);
        if (!fs.existsSync(scriptsDir)) {
            fs.mkdirSync(scriptsDir, { recursive: true });
        }
        
        fs.writeFileSync(resolverPath, resolverContent);
        console.log('ðŸ“ Created dynamic import resolver:', resolverPath);
    }

    /**
     * Generate import resolver content
     */
    generateImportResolver() {
        const { mainVersion } = this.currentConfig;
        const majorVersion = mainVersion.replace(/[\^~]/, '').split('.')[0];
        
        return `/**
 * OpenZeppelin Dynamic Import Resolver
 * Auto-generated by OpenZeppelinDynamicManager
 */

const ozVersion = ${majorVersion};

/**
 * Get the correct OpenZeppelin import path
 */
function getOZImport(contractName, category = 'access') {
    const basePath = '@openzeppelin/contracts';
    const categories = {
        access: 'access',
        security: 'security', 
        token: 'token',
        utils: 'utils',
        proxy: 'proxy',
        governance: 'governance'
    };
    
    const categoryPath = categories[category] || category;
    
    // Version-specific paths
    if (ozVersion >= 5) {
        const v5Mappings = {
            'AccessControl': 'access/AccessControl.sol',
            'Ownable': 'access/Ownable.sol',
            'Pausable': 'utils/Pausable.sol',
            'ReentrancyGuard': 'utils/ReentrancyGuard.sol',
            'IERC20': 'token/ERC20/IERC20.sol',
            'SafeERC20': 'token/ERC20/utils/SafeERC20.sol',
            'ECDSA': 'utils/cryptography/ECDSA.sol',
            'ERC165': 'utils/introspection/ERC165.sol'
        };
        
        return \`\${basePath}/\${v5Mappings[contractName] || \`\${categoryPath}/\${contractName}.sol\`}\`;
    } else {
        // v4.x fallback
        const v4Mappings = {
            'AccessControl': 'access/AccessControl.sol',
            'Ownable': 'access/Ownable.sol', 
            'Pausable': 'security/Pausable.sol',
            'ReentrancyGuard': 'security/ReentrancyGuard.sol',
            'IERC20': 'token/ERC20/IERC20.sol',
            'SafeERC20': 'token/ERC20/utils/SafeERC20.sol',
            'ECDSA': 'utils/cryptography/ECDSA.sol',
            'ERC165': 'utils/introspection/ERC165.sol'
        };
        
        return \`\${basePath}/\${v4Mappings[contractName] || \`\${categoryPath}/\${contractName}.sol\`}\`;
    }
}

/**
 * Get all OZ imports for a contract type
 */
function getOZBundle(bundleType) {
    const bundles = {
        'access-control': ['AccessControl', 'Ownable'],
        'security': ['Pausable', 'ReentrancyGuard'],
        'token': ['IERC20', 'SafeERC20'],
        'crypto': ['ECDSA'],
        'full': ['AccessControl', 'Ownable', 'Pausable', 'ReentrancyGuard', 'IERC20', 'SafeERC20', 'ECDSA']
    };
    
    const contracts = bundles[bundleType] || [];
    return contracts.map(contract => ({
        contract,
        import: getOZImport(contract)
    }));
}

/**
 * Check OZ compatibility
 */
function checkCompatibility(requiredContracts = []) {
    const issues = [];
    
    requiredContracts.forEach(contract => {
        try {
            const importPath = getOZImport(contract);
            // Could add actual file existence check here
        } catch (error) {
            issues.push(\`\${contract}: \${error.message}\`);
        }
    });
    
    return {
        compatible: issues.length === 0,
        issues,
        version: ozVersion
    };
}

module.exports = {
    ozVersion,
    getOZImport,
    getOZBundle,
    checkCompatibility
};
`;
    }

    /**
     * Update package.json for dynamic compatibility
     */
    async updatePackageConfiguration() {
        console.log('ðŸ“¦ Updating package configuration for dynamic OZ support...');
        
        const { packageJson } = this.currentConfig;
        
        // Add dynamic resolution script
        if (!packageJson.scripts) packageJson.scripts = {};
        packageJson.scripts['oz:check'] = 'node scripts/oz-dynamic-resolver.js';
        packageJson.scripts['oz:validate'] = 'node scripts/validate-oz-config.js';
        
        // Add PayRox OZ configuration
        if (!packageJson.payrox) packageJson.payrox = {};
        packageJson.payrox.ozDynamic = {
            enabled: true,
            version: this.currentConfig.mainVersion,
            lastUpdated: new Date().toISOString()
        };
        
        fs.writeFileSync(this.packageJsonPath, JSON.stringify(packageJson, null, 2));
        console.log('âœ… Package configuration updated');
    }

    /**
     * Create validation script
     */
    async createValidationScript() {
        const validatorContent = `/**
 * OpenZeppelin Configuration Validator
 */

const { getOZBundle, checkCompatibility } = require('./oz-dynamic-resolver');

async function validateOZConfig() {
    console.log('ðŸ” Validating OpenZeppelin configuration...');
    
    // Check all PayRox required contracts
    const requiredContracts = [
        'AccessControl',
        'Pausable', 
        'ReentrancyGuard',
        'IERC20',
        'SafeERC20',
        'ECDSA'
    ];
    
    const compatibility = checkCompatibility(requiredContracts);
    
    if (compatibility.compatible) {
        console.log(\`âœ… OpenZeppelin v\${compatibility.version} fully compatible!\`);
        
        // Show available bundles
        console.log('\\nðŸ“¦ Available OZ bundles:');
        const fullBundle = getOZBundle('full');
        fullBundle.forEach(({ contract, import: importPath }) => {
            console.log(\`  \${contract}: \${importPath}\`);
        });
        
        return true;
    } else {
        console.error('âŒ OpenZeppelin compatibility issues:');
        compatibility.issues.forEach(issue => console.error(\`  - \${issue}\`));
        return false;
    }
}

if (require.main === module) {
    validateOZConfig().then(success => {
        process.exit(success ? 0 : 1);
    });
}

module.exports = { validateOZConfig };
`;
        
        const validatorPath = path.join(process.cwd(), 'scripts', 'validate-oz-config.js');
        fs.writeFileSync(validatorPath, validatorContent);
        console.log('ðŸ“ Created OZ validation script:', validatorPath);
    }

    /**
     * Run complete dynamic setup
     */
    async setupDynamic() {
        console.log('ðŸš€ Setting up OpenZeppelin dynamic configuration...');
        
        try {
            await this.initialize();
            await this.updatePackageConfiguration();
            await this.createValidationScript();
            
            console.log('\\nâœ… OpenZeppelin dynamic setup complete!');
            console.log('\\nðŸŽ¯ Quick commands:');
            console.log('  npm run oz:check     - Check OZ configuration');
            console.log('  npm run oz:validate  - Validate full compatibility');
            
            return true;
        } catch (error) {
            console.error('âŒ Dynamic setup failed:', error.message);
            return false;
        }
    }

    /**
     * Generate runtime report
     */
    generateReport() {
        const { ozDependencies, mainVersion } = this.currentConfig;
        
        return {
            timestamp: new Date().toISOString(),
            mainVersion,
            dependencies: ozDependencies,
            status: 'dynamic-ready',
            compatibility: 'validated'
        };
    }
}

// CLI interface
if (require.main === module) {
    const manager = new OpenZeppelinDynamicManager();
    
    const command = process.argv[2] || 'setup';
    
    switch (command) {
        case 'setup':
            manager.setupDynamic();
            break;
        case 'validate':
            manager.initialize().then(() => {
                console.log('ðŸ“Š Configuration Report:');
                console.log(JSON.stringify(manager.generateReport(), null, 2));
            });
            break;
        default:
            console.log('Usage: node oz-dynamic-manager.js [setup|validate]');
    }
}

module.exports = OpenZeppelinDynamicManager;
